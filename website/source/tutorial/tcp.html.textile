---
title: Pipes
toc: true
---

h1. TCP/IP

TCP/IP channels come in two varieties: client-side channels and server-side
channels. Let me show you how to create both: 

<pre class="sh_ruby"><code title="Basic tcp">
  client = Cod.tcp('localhost:12345')
  server = Cod.tcp_server('localhost:12345')
  
  client.put 'tcp channels!'
  server.get # => "tcp channels!"
  
  client.close
  server.close
</code></pre>

To do simple communication across machines, this will be all you need. But that's only where things start, not where they end. In the following sections, 
I'll explain more about tcp clients and servers. 

h1. Client-side TCP

The channel returned by <code>Cod.tcp</code> really acts in two phases:

* Connection Phase: During this phase, the channel will buffer messages sent
  through it. No server could be contacted, so nothing goes over the wire. 
* Established Phase: Once the connection could be established, all messages 
  that have been buffered are now sent. From now on, everything gets 
  transmitted immediately. 

This two-phase connect is the reason why _cod_ programs can send stuff to a 
server that might not even be listening yet. This is very useful in practice.

h2. Read Timeouts

If you want to force a connection, try to read from the client channel. It
will block forever until data comes in. Look at this example, which tries to
read from the channel until a timeout occurs: 

<pre class="sh_ruby"><code title="Timeout">
  channel = Cod.tcp('localhost:12345')
  
  require 'timeout'
  begin
    value = timeout(0.1){ channel.get } 
  rescue Timeout::Error
  end
</code></pre>

Since there is normally no server on localhost:12345, the code will just block
and wait, trying to make a connection. After 0.1 seconds, the timeout 
occurs and we abort processing. 

We have chosen not to handle timeouts in _cod_ at all. A connection that did
not deliver the data in time will often need to be reset; the data might still
come later, and the client might not be in a condition to handle it. Use
<code>timeout.rb</code>, it is your friend.

h2. Connection lost

When the server terminates the connection to our client, we'll eventually get
a <code>Cod::ConnectionLost</code> error raised. This is pretty much the only
error you have to expect and handle. 

<pre class="sh_ruby"><code>
  # Read until the connection breaks.
  begin
    loop { client.get }
  rescue Cod::ConnectionLost
  end
</code></pre>


h1. Server-side TCP

Writing a server with cod involves a few more concerns and tricks than writing
a client. We've tried to address all obvious needs. Let's look at what the 
innermost interaction with cod looks like naively: 

<pre class="sh_ruby"><code>
  # Get request
  channel.get 
  # Put answer
  channel.put     # XXX doesn't exist
</code></pre>

But there is no <code>Channel#put</code> for tcp server channels! A tcp server
can of course have more than one client. There would be no way to tell which
client should receive the answer. 

The easy answer to solving this problem is of course to send the server the
channel to answer to. Here's a working example of this:[1]

<pre class="sh_ruby"><code title="A more realistic server">
  pid = client do 
    channel = Cod.tcp('127.0.0.1:12345')
    version = channel.interact [:ehlo, channel]
    version # => [:version, 1]

    other = channel.interact [:bark, channel]
    other # => :unknown_command

    # Tell the server to shut down.
    channel.put [:shutdown, nil]
  end
  
  server do
    channel = Cod.tcp_server('127.0.0.1:12345')
    
    loop do
      msg, client = channel.get
      case msg
        when :ehlo
          client.put [:version, 1]
        when :shutdown
          break
      else
        client.put :unknown_command
      end
    end
  end
  
  Process.wait pid
</code></pre>

h2. Identifying the Client

h3. Send it Over

h3. Implicit Identification

h2. Waiting for Data

h2. Dispatch Ideas

h3. The case Gem

h3. A clever Hash

h1. Competitive Comparison

Although we're pretty sure that cod doesn't perform badly, it probably will
not quite match your evented/fiberthreaded/control-inversed server. Writing
such a server is still hard. Comparing something you wrote in 5 minutes using
_cod_ to a program tuned for IO will not be a fair comparison.

Evented IO is mostly overkill in day to day programming. Threading can be and
often is actually harmful. What _cod_ proposes is a saner and less convoluted
way of expressing your needs. Make your choice. 

!/images/fish.png!

fn1. <code>#client</code> and <code>#server</code> are helper methods that
  fork a client or a server process respectively. Treat them as synonymous to
  <code>Kernel.fork</code>.

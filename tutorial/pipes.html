<!DOCTYPE html>
<html>
  <head>
    <link href="http://fonts.googleapis.com/css?family=Dosis" rel="stylesheet" type="text/css" /><link href="/cod/stylesheets/sh_whitengrey.css" media="screen" rel="stylesheet" type="text/css" /><link href="/cod/stylesheets/site.css" media="screen" rel="stylesheet" type="text/css" /><script src="/cod/javascripts/sh_main.min.js" type="text/javascript"></script><script src="/cod/javascripts/sh_ruby.min.js" type="text/javascript"></script><title>Pipes</title>
  </head>
  <body onload="sh_highlightDocument();"><h1>Pipes</h1>
<p>A pipe is a descriptor pair for interprocess communication.<sup class="footnote" id="fnr1"><a href="#fn1">1</a></sup> It allows data
to flow in one direction, from its read end to the write end. In a way, a 
pipe is the prototypical <em>cod</em> channel; they have been standing model for how
channels work.</p>
<p>Pipes are mainly used to communicate with subprocesses; they can be accessed
by everyone in the process group of the creating process. The patterns shown
here will illustrate what real uses such communication can have.</p>
<p>Pipes can be closed on either end. If the last write end is closed, further
reads will raise a <code>Cod::ConnectionLost[2]</code>.</p>
<h2>Basics</h2>
<p>Pipes in <em>cod</em> are constructed using</p>
<pre class="sh_ruby"><code>
  Cod.pipe
</code></pre>
<p>This returns a pipe that is either to be used for writing or for reading, 
but never both. If you really need both ends of a pipe in one and the same
process, you should use either of these two obtain two copies:</p>
<pre class="sh_ruby"><code>
  # either call #dup
  copy = pipe.dup

  # or call #split (this closes pipe)
  read, write = pipe.split
</code></pre>
<p>The penalty for not doing this is exceptions, so there, I warned you.</p>
<h2>When using forked processes</h2>
<p>When you create a process fork (<code>Kernel.fork</code>) on the other hand,
things become really simple. The only thing you need to be sure of is that you
don&#8217;t access the pipes you create before you create the fork. This would close
either end and render them useless:</p>
<pre class="sh_ruby"><code title="Access before fork">
  chan = Cod.pipe
  chan.put :smthng  # raises &lt;Errno::EPIPE: Broken pipe&gt;
  fork do
    chan.get
  end
</code></pre>
<p>Instead, create your pipes and only then fork all the processes you need to
communicate with. They will see your pipes because they inherit memory and
open IO streams from you; writing or reading from the pipes will still close
the other end, but that will happen in separate processes. This is the
advantage of share-nothing concurrency. Do this:</p>
<pre class="sh_ruby"><code title="simple IPC, in the right order">
  chan = Cod.pipe
  fork do
    chan.put :test
  end
  chan.get # =&gt; :test
</code></pre>
<h2>Communicate with Subprocesses, 101</h2>
<p>Let&#8217;s assume we want to run a subprocess and have it produce a value for us.
This is really a solved problem<sup class="footnote" id="fnr3"><a href="#fn3">3</a></sup>, but let&#8217;s assume it isn&#8217;t. <em>cod</em> makes
this easy:</p>
<pre class="sh_ruby"><code title="Heavy Computation">
  def heavy_computation # nomen est omen
    41 + 1
  end
  
  channel = Cod.pipe
  fork do
    channel.put heavy_computation()
  end

  channel.get # =&gt; 42
</code></pre>
<p>No need to stop the world just to get a simple answer; you fork a subprocess
and read the answer from a <em>cod</em> channel.</p>
<p>A few things to note. <em>cod</em> is a friendly fellow, it communicates in Ruby values by default. This frequently comes in very handy indeed. If you happen
to run into one of the infrequent cases where this bothers you, please skip
ahead to the chapter on <a href="serialisation.html">serialisation</a>.</p>
<p>Also, <em>cod</em> will often block if you issue a <code>#get</code>. This is really
a feature, not a bug. If you need to wait for new data to come in while doing
other work, please look at <a href="select.html">Cod.select</a></p>
<p>Have a look at this nifty trick:</p>
<pre class="sh_ruby"><code title="Passing back exceptions">
  channel = Cod.pipe
  fork do
    begin
      fail "Meanwhile, back at the ranch:"
    rescue =&gt; ex
      channel.put ex
    end
  end
  
  channel.get    # =&gt; #&lt;RuntimeError: Meanwhile, back at th...
</code></pre>
<p>One could even raise the error returned in the parent process, simulating a 
single process executing.</p>
<h2>N:M patterns</h2>
<p>Want to distribute work to a few workers and gather their results? <em>cod</em> works
for that as well. Here&#8217;s an example of N message producers, one consumer:</p>
<pre class="sh_ruby"><code title="n producers">
  pipe = Cod.pipe
  
  pids = 10.times.map { 
    fork { 
      pipe.put Process.pid } }
  
  communicated_pids = 10.times.map { pipe.get }
  pids.sort == communicated_pids.sort  # =&gt; true
</code></pre>
<p>And here &#8217;s an example of one producer, M consumers:</p>
<pre class="sh_ruby"><code title="m consumers">  
  # A simple worker class
  Worker = Struct.new(:n) do
    def work_on(from, to)
      loop do
        work_item = from.get
        to.put [n, work_item]
      end
    end
  end
  def Worker(n)
    Worker.new(n)
  end
  
  work = Cod.pipe   # for sending work to workers
  result = Cod.pipe # for receiving results from workers
  
  # Set up ten worker processes
  pids = 10.times.map do |i| 
    fork { Worker[i].work_on(work, result) }
  end
  
  # Distribute some work
  10.times { |i| work.put (i+1) }
  
  # Read back the results
  10.times.map { 
    p result.get } 
  
  pids.each { |pid| Process.kill(:TERM, pid) }
</code></pre>
<p>Output will look like this:</p>
<pre class="output dontrepeat">
[1, 1]
[3, 2]
[9, 3]
[6, 4]
[4, 5]
[0, 6]
[2, 7]
[2, 8]
[5, 9]
[7, 10]
</pre>
<p>&#8230; in best case. Be warned, process scheduling is not as fine in granularity
as thread scheduling is. The number of cores of the system you&#8217;re on and the
operating system that you&#8217;re running this under will dramatically effect these
results. Sometimes it is hard to get more than one processor to read from 
a single pipe.</p>
<h2>The Self Pipe</h2>
<p>When using processes instead of threads, you will sooner or later have to
handle signals using <code>Kernel.trap</code>.<sup class="footnote" id="fnr4"><a href="#fn4">4</a></sup> To be able to integrate this
nicely with the rest of your code that probably blocks in
<code>Cod.select</code> as much as possible, you can use the self-pipe
trick.</p>
<p>Rather than cover what a self-pipe is again, I refer you to the
<a href="http://cr.yp.to/docs/selfpipe.html">extensive</a>
<a href="http://osiris.978.org/~alex/safesignalhandling.html">documentation</a>
<a href="news://gmane.org:119/20120326222500.GA20806@dcvr.yhbt.net">online</a>. &#8217;cause
this is an old trick!</p>
<p>Using <em>cod</em>, it boils down to this:</p>
<pre class="sh_ruby"><code title="Self Pipe trick">
  self_pipe = Cod.pipe.split
  # Register a handler for USR1
  trap(:USR1) { self_pipe.write.put :USR1 }

  Process.kill(:USR1, 
    Process.pid)
  
  # Do something without worrying about signals
  
  # Here's the advantage of self-pipe: You can decide when 
  # to listen for signals. Otherwise trap is very preemptive.
  self_pipe.read.get # =&gt; :USR1
</code></pre>
<p>Did you notice that a split pipe returns an array that also answers to 
<code>#read</code> and <code>#write</code>? This is useful for when you cannot
come up with a name for both ends, as in the above example.</p>
<p class="footnote" id="fn1"><a href="#fnr1"><sup>1</sup></a> man 2 pipe</p>
<p class="footnote" id="fn2"><a href="#fnr2"><sup>2</sup></a> @code_link(Cod::ConnectionLost)</p>
<p class="footnote" id="fn3"><a href="#fnr3"><sup>3</sup></a> Something that another library of mine could help you with:
<a href="https://github.com/kschiess/procrastinate">procrastinate</a> by doing your work
in child processes.</p>
<p class="footnote" id="fn4"><a href="#fnr4"><sup>4</sup></a> This has pitfalls. Have a look at the section titled &#8220;Signal handling
might mess up library X&#8221; in the <a href="unix.html">chapter on unix tricks</a>.</p></body>
</html>